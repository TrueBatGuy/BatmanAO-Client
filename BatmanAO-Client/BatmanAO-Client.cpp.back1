// BatmanAO-Client.cpp
// Build (Developer Command Prompt for VS):
//   cl /EHsc /O2 BatmanAO-Client.cpp winhttp.lib advapi32.lib
// Usage (интерактивно): просто запустить и ввести адрес (http://domain[:port]/)
// Usage (без вопросов):
//   BatmanAO-Client.exe --server http://your-domain:8385/ [--game "C:\...\Batman Arkham Origins"] [--test]
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <winhttp.h>
#include <shlwapi.h>
#include <cstdio>
#include <string>
#include <vector>
#include <ctime>

#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "Advapi32.lib")
#pragma comment(lib, "Shlwapi.lib")

static bool fileExists(const std::wstring& p) {
    DWORD a = GetFileAttributesW(p.c_str());
    return a != INVALID_FILE_ATTRIBUTES && !(a & FILE_ATTRIBUTE_DIRECTORY);
}
static bool dirExists(const std::wstring& p) {
    DWORD a = GetFileAttributesW(p.c_str());
    return a != INVALID_FILE_ATTRIBUTES && (a & FILE_ATTRIBUTE_DIRECTORY);
}

static bool readAll(const std::wstring& path, std::string& out) {
    FILE* f = _wfopen(path.c_str(), L"rb");
    if (!f) return false;
    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    if (sz < 0) { fclose(f); return false; }
    fseek(f, 0, SEEK_SET);
    out.resize(sz);
    if (sz && fread(&out[0], 1, sz, f) != (size_t)sz) { fclose(f); return false; }
    fclose(f);
    return true;
}
static bool writeAll(const std::wstring& path, const std::string& data) {
    FILE* f = _wfopen(path.c_str(), L"wb");
    if (!f) return false;
    bool ok = fwrite(data.data(), 1, data.size(), f) == data.size();
    fclose(f);
    return ok;
}

static std::wstring getRegStr(HKEY root, const wchar_t* sub, const wchar_t* name) {
    HKEY h{};
    if (RegOpenKeyExW(root, sub, 0, KEY_READ, &h) != ERROR_SUCCESS) return L"";
    wchar_t buf[4096]; DWORD type = 0, cb = sizeof(buf);
    LONG r = RegGetValueW(h, nullptr, name, RRF_RT_REG_SZ, &type, buf, &cb);
    RegCloseKey(h);
    if (r == ERROR_SUCCESS) return std::wstring(buf);
    return L"";
}

static std::wstring autoDetectGameDir() {
    // Steam path from registry
    std::wstring steam = getRegStr(HKEY_LOCAL_MACHINE, L"SOFTWARE\\WOW6432Node\\Valve\\Steam", L"InstallPath");
    if (steam.empty())
        steam = getRegStr(HKEY_CURRENT_USER, L"SOFTWARE\\Valve\\Steam", L"SteamPath");
    if (!steam.empty()) {
        std::wstring g = steam + L"\\steamapps\\common\\Batman Arkham Origins";
        if (dirExists(g)) return g;
    }
    // Fallbacks (на некоторых системах Steam ставится сюда)
    const wchar_t* guesses[] = {
        L"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Batman Arkham Origins",
        L"D:\\Steam\\steamapps\\common\\Batman Arkham Origins",
        L"E:\\Steam\\steamapps\\common\\Batman Arkham Origins",
        nullptr
    };
    for (int i = 0; guesses[i]; ++i) {
        if (dirExists(guesses[i])) return guesses[i];
    }
    return L"";
}

static std::wstring iniPathFromGameDir(const std::wstring& gameDir) {
    return gameDir + L"\\Online\\BmGame\\Config\\DefaultWBIDVars.ini";
}

static std::wstring nowStamp() {
    wchar_t buf[64];
    std::time_t t = std::time(nullptr);
    std::tm tm{};
    localtime_s(&tm, &t);
    swprintf(buf, 64, L"%04d%02d%02d_%02d%02d%02d",
        tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
    return buf;
}

static bool backupFile(const std::wstring& src) {
    std::wstring dst = src + L".bak." + nowStamp();
    if (!CopyFileW(src.c_str(), dst.c_str(), TRUE)) {
        // если уже есть .bak с таким именем – попробуем без timestamp
        dst = src + L".bak";
        if (!CopyFileW(src.c_str(), dst.c_str(), FALSE)) return false;
    }
    return true;
}

static std::string trim(const std::string& s) {
    size_t a = s.find_first_not_of(" \t\r\n");
    size_t b = s.find_last_not_of(" \t\r\n");
    if (a == std::string::npos) return "";
    return s.substr(a, b - a + 1);
}

static std::string normalizeBaseUrl(std::string u) {
    u = trim(u);
    if (u.empty()) return u;
    // Добавим схему, если нет
    if (u.rfind("http://", 0) != 0 && u.rfind("https://", 0) != 0) {
        u = "http://" + u;
    }
    // Добавим завершающий '/'
    if (u.back() != '/') u.push_back('/');
    return u;
}

static bool patchIni(const std::wstring& iniPath, const std::string& baseUrlIn) {
    std::string text;
    if (!readAll(iniPath, text)) return false;

    // Определим "глобальный" EOL файла (по первой найденной строке)
    std::string fileEol = "\n";
    {
        size_t p = text.find('\n');
        if (p != std::string::npos && p > 0 && text[p - 1] == '\r') fileEol = "\r\n";
    }

    std::string baseUrl = baseUrlIn;                // уже нормализован заранее
    std::string out; out.reserve(text.size() + 128);

    size_t i = 0;
    bool replaced = false;
    while (i < text.size()) {
        size_t e = text.find('\n', i);
        size_t len = (e == std::string::npos) ? (text.size() - i) : (e - i + 1);
        std::string raw = text.substr(i, len);

        // Определим EOL конкретно у этой строки
        std::string lineEol = "";
        if (!raw.empty()) {
            if (raw.back() == '\n') {
                lineEol = (raw.size() >= 2 && raw[raw.size() - 2] == '\r') ? "\r\n" : "\n";
            }
        }

        // Сама строка без EOL
        std::string line = raw;
        if (!lineEol.empty()) line.erase(line.size() - lineEol.size());

        std::string s = trim(line);
        if (s.rfind("BaseUrl=", 0) == 0) {
            // Пишем с кавычками и сохраняем EOL этой строки
            out += "BaseUrl=\"" + baseUrl + "\"" + lineEol;
            replaced = true;
        }
        else {
            out += raw; // оставляем как было
        }

        if (e == std::string::npos) break;
        i = e + 1;
    }

    if (!replaced) {
        // Если строки не было — добавим в конец, используя EOL файла
        if (!out.empty() && (out.back() != '\n' && out.back() != '\r')) out += fileEol;
        out += "BaseUrl=\"" + baseUrl + "\"" + fileEol;
    }

    return writeAll(iniPath, out);
}


static bool parseHostPortPath(const std::string& url, std::wstring& host, INTERNET_PORT& port, std::wstring& path) {
    // Очень простой парсер: ожидаем http(s)://host[:port]/path...
    std::string u = url;
    if (u.rfind("http://", 0) == 0) {
        u.erase(0, 7);
        port = 80;
    }
    else if (u.rfind("https://", 0) == 0) {
        u.erase(0, 8);
        port = 443;
    }
    else return false;

    size_t slash = u.find('/');
    std::string hostport = (slash == std::string::npos) ? u : u.substr(0, slash);
    std::string pth = (slash == std::string::npos) ? "/" : u.substr(slash);

    size_t colon = hostport.find(':');
    std::string h = (colon == std::string::npos) ? hostport : hostport.substr(0, colon);
    if (colon != std::string::npos) {
        port = (INTERNET_PORT)atoi(hostport.substr(colon + 1).c_str());
        if (!port) port = 80;
    }

    int wlen = MultiByteToWideChar(CP_UTF8, 0, h.c_str(), -1, nullptr, 0);
    std::wstring wh(wlen ? wlen - 1 : 0, L'\0');
    if (wlen > 0) MultiByteToWideChar(CP_UTF8, 0, h.c_str(), -1, &wh[0], wlen);

    wlen = MultiByteToWideChar(CP_UTF8, 0, pth.c_str(), -1, nullptr, 0);
    std::wstring wp(wlen ? wlen - 1 : 0, L'\0');
    if (wlen > 0) MultiByteToWideChar(CP_UTF8, 0, pth.c_str(), -1, &wp[0], wlen);

    host = wh; path = wp;
    return true;
}

static bool httpGetJson(const std::string& baseUrl, const std::string& rel, bool httpsOk = true) {
    std::string full = baseUrl;
    if (!full.empty() && full.back() == '/' && !rel.empty() && rel.front() == '/')
        full.pop_back();
    full += rel;

    std::wstring host, path;
    INTERNET_PORT port = 0;
    if (!parseHostPortPath(full, host, port, path)) return false;

    bool isHttps = (full.rfind("https://", 0) == 0);
    HINTERNET hSes = WinHttpOpen(L"AOClientPatcher/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    if (!hSes) return false;
    HINTERNET hCon = WinHttpConnect(hSes, host.c_str(), port, 0);
    if (!hCon) { WinHttpCloseHandle(hSes); return false; }
    HINTERNET hReq = WinHttpOpenRequest(hCon, L"GET", path.c_str(), NULL,
        WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES,
        isHttps ? WINHTTP_FLAG_SECURE : 0);
    if (!hReq) { WinHttpCloseHandle(hCon); WinHttpCloseHandle(hSes); return false; }

    BOOL ok = WinHttpSendRequest(hReq, WINHTTP_NO_ADDITIONAL_HEADERS, 0, 0, 0, 0, 0)
        && WinHttpReceiveResponse(hReq, NULL);
    if (!ok) {
        WinHttpCloseHandle(hReq); WinHttpCloseHandle(hCon); WinHttpCloseHandle(hSes);
        return false;
    }
    DWORD status = 0, sz = sizeof(status);
    WinHttpQueryHeaders(hReq, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &status, &sz, NULL);
    // читаем немного тела (не обязательно)
    WinHttpCloseHandle(hReq); WinHttpCloseHandle(hCon); WinHttpCloseHandle(hSes);
    return (status >= 200 && status < 400);
}

void PrintBatBar() {
    printf(
        "\n"
        "                      _.-/                                                \\-._\n"
        "                    ./  /                                                  \\  \\.\n"
        "                  ./    \\.                    /\\    /\\                    ./    \\.\n"
        "                ./       \\.                  /  \\__/  \\                  ./       \\.\n"
        "              ./           \\___             /          \\             ___/           \\.\n"
        "            ./                 ---______---/            \\---______---                 \\.\n"
        "          ./                                                                            \\.\n"
        "         /                                                                                \\ \n"
        "        /                                                                                  \\\n"
        "       /.                                                                                  .\\\n"
        "       /          ___                                                          ___          \\ \n"
        "      /     ___---   ---___  ___                                    ___  ___---   ---___     \\\n"
        "     /  _---               \\/   ---___                        ___---   \\/               ---_  \\\n"
        "     /./                              ---___            ___---                              \\.\\\n"
        "     //                                     ---.    .---                                     \\\\\n"
        "                                               \\    /\n"
        "                                                \\  /\n"
        "                                                 \\/\n"
        "\n                            C O N N E C T E D    T O    B A T C O M P U T E R \n\n"
    );
    return;
}

int wmain(int argc, wchar_t** wargv) {
    SetConsoleOutputCP(CP_UTF8);

    std::wstring gameDir;
    std::string server;
    bool doTest = false;

    // parse args
    for (int i = 1; i < argc; i++) {
        if (lstrcmpiW(wargv[i], L"--game") == 0 && i + 1 < argc) {
            gameDir = wargv[++i];
        }
        else if (lstrcmpiW(wargv[i], L"--server") == 0 && i + 1 < argc) {
            int n = WideCharToMultiByte(CP_UTF8, 0, wargv[++i], -1, nullptr, 0, 0, 0);
            server.resize(n ? n - 1 : 0);
            if (n > 0) WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1, &server[0], n, 0, 0);
        }
        else if (lstrcmpiW(wargv[i], L"--test") == 0) {
            doTest = true;
        }
    }

    if (gameDir.empty()) {
        gameDir = autoDetectGameDir();
    }
    if (gameDir.empty() || !dirExists(gameDir)) {
        wprintf(L"Unable to find game marker. Please enter the path to \"Batman Arkham Origins\":\n> ");
        wchar_t buf[MAX_PATH * 4]; if (!fgetws(buf, MAX_PATH * 4, stdin)) return 1;
        std::wstring path = buf; while (!path.empty() && (path.back() == L'\n' || path.back() == L'\r')) path.pop_back();
        if (!dirExists(path)) { wprintf(L"The folder does not exist.\n"); return 1; }
        gameDir = path;
    }

    std::wstring ini = iniPathFromGameDir(gameDir);
    if (!fileExists(ini)) {
        wprintf(L"INI not found: %s\nExpected: Online\\BmGame\\Config\\DefaultWBIDVars.ini\n", ini.c_str());
        return 1;
    }

    if (server.empty()) {
        printf("Enter the server address (example: http://your-domain:8385/ or your-domain:8385):\n> ");
        char buf[1024]; if (!fgets(buf, sizeof(buf), stdin)) return 1;
        server = buf;
    }
    // normalize
    server = normalizeBaseUrl(server);
    if (server.empty()) { printf("Empty address.\n"); return 1; }

    // test server
    printf("Server check: %sstore/catalog/general ...\n", server.c_str());
    bool ok = httpGetJson(server, "/store/catalog/general");
    if (!ok && !doTest) {
        printf("Warning: The server did not respond. 2xx/3xx. Continue patch? [y/N]: ");
        int c = getchar(); if (c != 'y' && c != 'Y') return 2;
        // дочистим stdin
        while (c != '\n' && c != EOF) c = getchar();
    }
    else if (ok) {
        printf("OK: The server is responding.\n");
        PrintBatBar();
    }

    // backup
    if (!backupFile(ini)) {
        wprintf(L"Warning: Failed to create backup INI.\n");
    }

    // patch
    if (!patchIni(ini, server)) {
        wprintf(L"Error: Failed to write INI.\n");
        return 3;
    }

    wprintf(L"Done! BaseUrl updated -> %S\nINI: %s\n", server.c_str(), ini.c_str());
    printf("Launch the game. To restore it, restore the .bak file next to the INI.\n");
    return 0;
}
